# Ch10 程序结构

本章讨论一个程序包含多个函数时所产生的几个问题。



本章内容

局部变量和外部变量之间的差异

考虑程序块（含有声明的复合语句）问题

解决用于局部名、外部名和在程序块中声明的名字的作用域规则问题

用来组织函数原型、函数定义、变量声明和程序其他部分的方法

## 10.1 局部变量

我们把函数体内声明的变量称为该函数的***局部变量***（local variable）。在下面的函数中，`sum`是局部变量：

```c
int sum_digits(int n)
{
  int sum = 0;				/* local variable */
  
  while (n > 0) {
    sum += n % 10;
    n /= 10;
  }
  
  return sum;
}
```

默认情况下，局部变量具有下列性质。

- 自动存储期限（automatic storage duration）。变量的存储期限（storage duration）（或存储长度）是在变量存储单元存在期内程序执行的部分。局部变量的存储单元是在包含该变量的函数被调用时“自动”分配的，函数返回时收回分配，所以称这种变量具有自动的存储期限。包含局部变量的函数返回时，局部变量的值无法保留。当再次调用该函数时，无法保证变量拥有原先的值。
- 块作用域（Block scope）。变量的作用域是可以引用该变量的程序文本的部分。局部变量拥有块作用域：从变量声明的点开始一直到所在函数体的末尾。因为局部变量的作用域不能延伸到其所属函数之外，所以其他函数可以把同名变量用于别的用途。

（C99）C99不要求在函数一开始就进行变量声明，所以局部变量的作用域可能非常小。在接下来的这个例子中，变量`i`的作用域从声明该变量的代码行开始，此时可能已经接近函数体的末尾了：

```c
void f(void)
{
  ...
  int i;  /* i的作用域从这里开始 */
  ...
}					/* i的作用域到这里结束 */
```

### 10.1.1 静态局部变量

在局部变量声明中放置单词`static`可以使变量具有静态存储期限（static storage duration）而不再是自动存储期限。因为具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。思考下面的函数：

```c
void f(void)
{
  static int i;			/* static local variable */
  ...
}
```

因为局部变量`i`已经声明为`static`，所以在程序执行期间它所占据的内存单元是不变的。在`f`返回时，变量`i`不会丢失其值。

静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其他函数隐藏数据的地方，但是它会为将来同一个函数的在调用保留这些数据。

### 10.1.2 形式参数

形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。事实上，形式参数局部变量唯一真正的区别是，在每次函数调用时对形式参数自动进行初始化（调用中通过赋值获得相应实际参数的值）。

## 10.2 外部变量

传递参数是给函数传递信息的一种方法。函数还可以通过***外部变量***（external variable）进行通信。外部变量是声明在任何函数体外的。

外部变量（有时称为全局变量（global variables））的性质不同于局部变量的性质。

- 静态存储期限。就如同声明为`static`的局部变量一样，外部变量拥有静态存储期限。存储在外部变量中的值将永久保留下来。
- 文件作用域（file scope）。外部变量拥有文件作用域：从变量被声明的点开始一直到所在文件的末尾。因此，跟随在外部变量声明之后的所有函数都可以访问（并修改）它。

### 10.2.1 示例：用外部变量实现栈（stack）

像数组一样，栈可以存储具有相同数据类型的多个数据项。然而，栈操作是受限制的：只可以往栈中压入（push）数据项（把数据项加在一端——“栈顶”）或者从栈中弹出（pop）数据项（从同一端移走数据项）。禁止测试或修改不在栈顶顶数据项。

C语言中实现栈的一种方法是把元素存储在数组中，我们称这个数组为`contents`。命名为`top`的一个整型变量用来标记栈顶的位置。栈为空时，`top`的值为0。为了往栈中压入数据项，可以把数据项简单存储在`contents`中由`top`指定的位置上，然后自增`top`。弹出数据项则要求自减`top`，然后用它作为`contents`的索引取回弹出的数据项。

基于上述这些概要，这里有一段代码（不是完整的程序）为栈声明了变量`contents`和`top`并且提供了一组函数来表示对栈的操作。全部5个函数都需要访问变量`top`，而且其中2个函数还都需要访问`contents`，所以将把`contents`和`top`设为外部变量。

```c
#include <stdbool.h>		/* C99 only */
#define STACK_SIZE 100

/* external variables */
int contents[STACK_SIZE]
int top;

void make_empty(void)
{
  top = 0;
}

bool is_empty(void)
{
  return top == 0;
}

bool is_full(void)
{
  return top == STACK_SIZE;
}

void push(int i)
{
  if (is_full())
    stack_overflow();
  else
    contents[top++] = i;
}

int pop(void)
{
  if (is_empty())
    stack_underflow();
  else
    return contents [--top];
}
```

### 10.2.2 外部变量的利与弊

在多个函数必须共享一个变量时或者少数几个函数共享大量变量时，外部变量是很有用的。然而，在大多数情况下，对函数而言，通过形式参数进行通信比通过共享变量的方法更好。下面列举的是原因

- 在程序维护期间，如果改变外部变量（比方说改变它的类型），那么将需要检查同一文件中的每个函数，以确认该变化如何对函数产生影响。
- 如果外部变量被赋予了错误的值，可能很难确定出错的函数。
- 很难在其他程序中复用依赖于外部变量的函数。依赖外部变量的函数不是“独立的”。为了在另一个程序中使用该函数，必须带上此函数需要的外部变量。

使用外部变量时，要确保它们都拥有有意义的名字。（局部变量不是总需要有意义的名字的，因为往往很难为`for`循环中的控制变量起一个比`i`更好的名字。）如果你发现为外部变量使用的名字就像`i`和`temp`一样，这可能意味着这些变量其实应该是局部变量。

## 10.3 程序块

之前遇到过下列形式的复合语句：

```c
{ statements }
```

C语言还允许包含声明的复合语句：

```c
{ declarations statements }
```

这里将采用术语程序块（block）来描述这类复合语句。下面是程序块的示例：

```c
if (i > j) {
  /* swap values of i and j */
  int temp = i;
  i = j;
  j = temp;
}
```

默认情况下，声明在程序块中的变量的存储期限是自动的；进入程序块时为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说，不能在程序块外引用。

函数体是程序块。在需要临时使用的变量时，函数体内的程序块也是非常有用的。在上面的例子中，我们需要一个临时变量以便可以变换`i`和`j`的值。在程序块中放置临时变量有两个好处：（1）避免函数体起始位置的声明与只是临时使用的变量相混淆，（2）减少了名字冲突。在此例中，名字`temp`可以根据不同的目的用于同一函数中的其他地方，在程序块中声明的变量`temp`严格局限于程序块。

（C99）C99允许在程序块的任何地方声明变量，就像允许在函数体内的任何地方声明变量一样。

## 10.4 作用域

在C程序中，相同的标识符可以有不同的含义。C语言的作用域规则使得程序员（和编译器）可以确定与程序中给定点相关的哪种含义。下面是重要的作用域规则：当程序块内的声明命名一个标识符时，如果此标识符已经是可见的（因为此标识符拥有文件作用域，或者因为它已在某个程序块内声明），新的声明临时“隐藏”了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的含义。

## 10.5 构建C程序

C程序可以包含：

- 诸如`#include`和`#define`这样的预处理指令；
- 类型定义；
- 外部变量声明；
- 函数原型；
- 函数定义。

C语言对上述这些项的顺序要求极少：执行到预处理指令所在的代码行时，预处理指令才会起作用；类型名定义后才可以使用；变量声明后才可以使用。虽然C语言对函数没有什么要求，但是这里强烈建议在第一次调用函数前要对每个函数进行定义或声明。（至少C99要求我们这么做）

为了遵守这些规则，这里有几个构建程序的方法。下面是一种可能的编排顺序：

- `#include`指令；
- `#define`指令；
- 类型定义；
- 外部变量的声明；
- 除`main`函数之外的函数的原型；
- `main`函数的定义；
- 其他函数的定义。

因为`#include`指令带来的信息可能在程序中的好几个地方需要，所以先放置这条指令是合理的。`#define`指令创建宏，对这些宏的使用通常遍布整个程序。类型定义放置在外部变量声明的上面是合乎逻辑的，因为这些外部变量的声明可能会引用刚刚定义的类型名。接下来，声明外部变量使得它们对于跟随在其后的所有函数都是可用的。在编译器看见原型之前调用函数，可能会产生问题，而此时声明除了`main`函数以外的所有函数可以避免这些问题。这种方法也使得无论用什么顺序编排函数定义都是可能的。例如，根据函数名的字母顺序编排，或者把相关函数组合在一起进行编排。在其他函数前定义`main`函数使得阅读程序的人容易定位程序的起始点。

在每个函数定义前放盒型注释可以给出函数名、描述函数的目的、讨论每个形式参数的含义、描述返回值（如果有的话）并罗列所有的副作用（如修改了外部变量的值）。

