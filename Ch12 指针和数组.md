# Ch12 指针和数组

当指针指向数组元素时，C语言允许对指针进行算术运算（加法和减法），通过这种运算我们可以用指针代替数组下标对数组进行处理。

C语言中的指针和数组的关系是非常紧密的。理解指针和数组之间的关系对于熟练掌握C语言非常关键：它能使我们深入了解C语言的设计过程，并且能够帮助我们理解现有的程序。然而，需要知道的是，用指针处理数组的主要原因是效率，但是这里的效率提升已经不再像当初那么重要了，这主要归功于编译器的改进。



本章内容

指针的算术运算，并且说明如何使用关系运算符和判等运算符进行指针的比较

示范如何用指针处理数组元素

揭示了一个关于数组的重要事实（即可以用数组的名字作为指向数组中第一个元素的指针），并且利用这个事实说明了数组型实际参数的真实工作机制

前3节的主题对于多维数组的应用

指针和变长数组之间的关系（C99）

## 12.1 指针的算术运算

指针可以指向数组元素。

```c
int a[10], *p;
p = &a[0];			/* 使p指向a[0] */
*p = 5;					/* 把值5写入a[0] */
```

通过在`p`上执行***指针算术运算***（地址算术运算）可以访问数组`a`的其他所有元素。C语言支持3种且只有3种格式的指针算术运算：

- 指针加上整数；
- 指针减去整数；
- 两个指针相减。

### 12.1.1 指针加上整数

指针`p`加上整数`j`产生指向特定元素的指针，这个特定元素是`p`原先指向的元素后的`j`个位置。更确切地说，如果`p`指向数组元素`a[i]`，那么`p+j`指向`a[i+j]`（当然，前提是`a[i+j]`必须存在）。

### 12.1.2 指针减去整数

如果`p` 指向数组元素`a[i]`，那么`p-j` 指向`a[i-j]`。

### 12.1.3 两个指针相减

当两个指针相减时，结果为指针之间的距离（用数组元素的个数来度量）。因此，如果`p`指向`a[i]`且`q`指向`a[j]`，那么`p-q`就等于`i-j`。

### 12.1.4 指针比较

可以用关系运算符（`<`、`<=`、`>`和`>=`）和判等运算符（`==`和`!=`）进行指针比较。只有在两个指针指向同意数组时，用关系运算符进行的指针才比较有意义。比较的结果依赖于数组中两个元素的相对位置。例如，在下面的赋值后`p <= q`的值是0，而`p >= q`的值是1。

```c
p = &a[5];
q = &a[1];
```

### 12.1.5 指向复合常量的指针（C99）

指针指向由复合字面量创建的数组中的某个元素是合法的。

复合字面量是C99的一个特性，可以用于创建没有名称的数组。

```c
int *p = (int []){3, 0, 3, 4, 1};
```

`p`指向一个五元数组的第一个元素，这个数组包括5个整数3，0，3，4和1。使用复合字面量可以减少一些麻烦，我们不再需要先声明一个数组变量，然后用指针`p`指向数组的第一个元素：

```c
int a[] = {3, 0, 3, 4, 1};
int *p = &a[0];
```

## 12.2 指针用于数组处理

指针的算术运算允许通过对指针变量进行重复自增来访问数组的元素。下面的这个对数组`a`中元素求和的程序段说明了这种方法。在这个示例中，指针变量`p`初始指向`a[0]`，每次执行循环时对`p`进行自增；因此`p`先指向`a[1]`，然后指向`a[2]`，以此类推。在`p`指向数组`a`对最后一个元素后循环终止。

```c
#define N 10
...
int a[N], sum, *p;
...
sum = 0;
for (p = &a[0]; p < &a[N]; p++)
  sum += *p;
```

**`*` 运算符和`++`运算符的组合**

| 表达式           |                  含义                  |
| :--------------- | :------------------------------------: |
| `*p++`或`*(p++)` | 自增前表达式的值是`*p`，以后再自增`p`  |
| `(*p)++`         | 自增前表达式的值是`*p`，以后再自增`*p` |
| `*++p`或`*(++p)` |   先自增`p`，自增后表达式的值是`*p`    |
| `++*p`或`++(*p)` |   先自增`*p`，自增后表达式的值是`*p`   |



## 12.3 用数组名作为指针

可以用数组的名字作为指向数组第一个元素的指针。例如

```c
int a[10];
*a = 7;				/* stores 7 in a[0]  */
*(a+1) = 12 	/* stores 12 in a[1] */
```

通常情况下，`a + i`等同于`&a[i]`（两者都表示指向数组`a`中元素`i`的指针），并且`*(a+i)`等价于`a[i]`（两者都表示元素`i`本身）。换句话说，可以把数组的取下标操作看成是指针算术运算的一种形式。



虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的：

```c
while (*a != 0)
  a++;				/*** WRONG ***/
```



### 12.3.1 数组型实际参数

数组名在传递给函数时，总是被视为指针。

把数组形式参数看作是指针会产生许多重要的结果。

- 在给函数传递普通变量时，变量的值会被复制；任何对相应的形式参数的改变都不会影响到变量。反之，因为没有对数组本身进行复制，所以作为实际参数的数组是可能被改变的。
- 给函数传递数组所需的时间与数组的大小无关。因为没有对数组进行复制，所以传递大数组不会产生不利的结果。
- 如果需要，可以把数组型形式参数声明为指针。
- 可以给形式参数为数组的函数传递数组的“片断“，所谓片断是指连续的数组元素组成的序列。

### 12.3.2 用指针作为数组名

C语言允许把指针看作数组名进行取下标操作。

```c
#define N 10
...
int a[N], sum = 0, *p = a;
...
for (i = 0; i < N, i++)
  sum += p[i];
```

编译器把`p[i]`看作`*(p+i)`，这是指针算术非常正规的方法。

##12.4 指针和多维数组

### 12.4.1 处理多维数组的元素

C语言按行主序存储二维数组；换句话说，先是0行的元素，接着是1行的，依次类推。

使用指针时可以利用这一布局特点。如果使指针`p`指向二维数组中的第一个元素（即0行0列的元素），就可以通过重复自增`p`的方法访问数组中的每一个元素。

```c
/* The problem of initializing all 
	 elements of a two-dimensional 
	 array to zero */
int a[NUM_ROWS][NUM_COLS];
int row, col;
...
for (row = 0; row < NUM_ROWS; row++)
  for (col = 0; col < NUM_COLS; col++)
    a[row][col] = 0;
```

但是，如果把`a`看成是一维的整型数组，那么就可以把上述两个循环改成一个循环了：

```c
int *p;
...
for (p = &a[0][0]; p <= &a[NUM_ROWS-1][NUM_COLS-1]; p++)
  *p = 0;
```

这类方法明显破坏了程序的可读性，但是至少对一些老的编译器来说这种方法在效率方面进行了补偿。不过，对许多现代的编译器来说，这样所获得的速度优势往往极少甚至完全没有。

### 12.4.2 处理多维数组的行

为了访问到第`i`行的元素，需要初始化`p`使其指向数组`a`中第`i`行的元素0:

```c
p = &a[i][0];
```

对于任意的二维数组`a`来说，由于表达式`a[i]`是指向第`i`行中的第一个元素（元素0）的指针，上面的语句可以简写为

```c
p = a[i];
```

 对于任意数组`a`来说，表达式`a[i]`等价于`*(a + i)`。因此`&a[i][0]`等同于`&(*(a[i]+0))`，而后者等价于`&*a[i]`；又因为`&`和`*`运算符可以抵消，也就等同于`a[i]`。下面的循环对数组`a`对第`i`行清零，其中用到了这一简化：

```c
int a[NUM_ROWS][NUM_COLS], *p, i;
...
for (p = a[i]; p < a[i] + NUM_COLS; p++)
  *p = 0;
```

因为`a[i]`是指向数组`a` 的第`i`行的指针，所以可以把`a[i]`传递给需要用一维数组作为实际参数的函数。换句话说，使用一维数组的函数也可以使用二维数组中的一行。

### 12.4.3 处理多维数组的列

处理二维数组的一列中的元素就没那么容易了，因为数组是按行而不是按列存储的。下面的循环对数组`a`对第`i`列清零：

```c
int a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS], i;
...
for (p = &a[0]; p < &a[NUM_ROWS]; p++)
  (*p)[i] = 0;
```

### 12.4.4 用多维数组名作为指针

就像一维数组的名字可以用作指针一样，无论数组的维数是多少都可以采用任意数组的名字作为指针。但是需要特别小心。

```c
int a[NUM_ROWS][NUM_COLS];
```

`a`不是指向`a[0][0]`的指针，而是指向`a[0]`的指针。

C语言认为`a`不是一个二维数组而是一维数组，且这个一维数组的每个元素又是一维数组。用作指针时，`a`的类型是`int (*)[NUM_COLS]`（指向长度为`NUM_COLS`的整型数组的指针）。

了解`a`指向的是`a[0]`有助于简化处理二维数组元素的循环。例如，为了把数组`a`的第`i`列清零，可以用

```c
for (p = &a[0]; p < &a [NUM_ROWS]; p++)
  (*p)[i] = 0;
```

另一种应用是巧妙地让函数把多维数组看成是一维数组。

## 12.5 C99中的指针和变长数组（C99）

普通的指针变量可以用于指向一维变长数组的元素：

```c
void f(int n)
{
  int a[n], *p;
  p = a;
  ...
}
```

如果变长数组是多维的，指针的类型取决于第一维外每一维的长度。下面是二维的情况：

```c
void f(int m, int n)
{
  int a[m][n], (*p)[n];
  p = a;
  ...
}
```

因为`p`的类型依赖于`n`，而`n`不是常量，所以说`p`具有可改变类型（variably modified type）。需要注意的是，编译器并非总能确定`p = a`这样的赋值语句的合法性。例如，下面的代码可以通过编译，但只有当$m = n$时才是正确的：

```c
int a[m][n], (*p)[m];
p = a;
```

如果$m \neq n$，后续对`p`对使用都将导致未定义的行为。

与变长数组一样，可改变类型也具有特定的限制，其中最重要的限制是，可改变类型的声明必须出现在函数体内部或者在函数原型中。

变长数组的指针算术运算和一般数组中的指针算术运算一样。

将第`i` 列清零：

```c
int a[m][n];
int (*p)[n];
for (p = a; p < a + m; p++)
  (*p)[i] = 0;
```
