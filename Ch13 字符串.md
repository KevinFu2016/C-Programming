# Ch13 字符串

本章内容

字符串字面量的规则，包括如何在字符串字面量中嵌入转义序列，如何分割较长的字符串字面量。

声明字符串变量的方法，字符串变量其实就是字符数组，不过末尾要加上一个特殊的空字符来标示字符串的末尾。

读/写字符串的方法

处理字符串函数的编写方法

一些C语言函数库中处理字符串的函数

处理字符串时经常会采用的惯用法

如何创建数组元素是指向不同长度字符串的指针的数组，以及C语言如何使用这种数组为程序提供命令行支持

## 13.1 字符串字面量

***字符串字面量***（string literal）是用一对双引号括起来的字符序列：

```c
"When you come to a fork in the road, take it."
```

字符串字面量常常作为格式串出现在`printf`函数和`scanf`函数的调用中。

### 13.1.1 字符串字面量的转义序列

字符串字面量可以像字符常量一样包含转义序列。例如

```c
"Candy\nIs dandy\nBut liquor\nIs quicker.\n --Ogden nash\n"
```

在字符串字面量中小心使用八进制数和十六进制数的转义序列。

### 13.1.2 延续字符串字面量

如果发现字符串字面量太长而无法放置在单独一行内，只要把第一行用字符`\`结尾，那么C语言就允许在下一行延续字符串字面量。除了（看不到的）末尾的换行符，在同一行不可以有其他字符跟在`\`后面：

```c
printf("When you come to a fork in the road, take it.   \
--Yogi Berra");
```

一般来说，字符`\`可以用来把两行或更多行的代码连接成一行（在C标准中这一过程称为“拼接（splicing）”）。

使用`\`有一个缺陷：字符串字面量必须从下一行的起始位置继续。因此，这就破坏了程序的缩进结构。根据下面的规则，处理长字符串字面量有一种更好的方法：当两条或更多条字符串字面量相邻时（仅用空白字符分割），编译器会把它们合并成一条字符串。这条规则允许把字符串分割放在两行或者更多行中：

```c
printf("When you come to a fork in the road, take it. "
       "--Yogi Berra");
```

### 13.1.3 如何存储字符串字面量

从本质而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为$n$的字符串字面量时，它会成为字符串字面量分配长度为$n+1$的内存空间。这块内存空间将用来存储字符串字面量中的字符，以及一个用来标志字符串末尾的额外字符（***空字符***（null character））。空字符是一个所有位都为0的字节，因此用转义序列`\0`来表示。

字符串字面量是作为数组来存储的，那么编译器会把它看作是`char *`类型的指针。

### 13.1.4 字符串字面量的操作

通常情况下可以在任何C语言允许使用`char *`指针的地方使用字符串字面量。

```c
char *p;
p = "abc";
```

这个赋值操作不是复制`"abc"`中的字符，而是使`p`指向字符串的第一个字符。

C语言允许对指针取下标，因此可以对字符串字面量取下标：

```c
char ch;
ch = "abc"[1];
```

`ch`的新值将是字母`b`。其他可能的下标是0（这将选择字母`a`）、2（字母`c`）和3（空字符）。

--------

试图改变字符串字面量会导致未定义的行为：

```c
char *p = "abc";
*p = 'd';			/*** WRONG ***/
```

改变字符串字面量可能会导致程序崩溃或运行不稳定。

### 13.1.5 字符串字面量与字符常量

只包含一个字符的字符串字面量不同于字符常量。字符串字面量`"a"`是用指针来表示的，这个指针指向存放字符`"a"`（后面紧跟空字符）的内存单元。字符常量`'a'`是用整数（字符集的数值码）来表示的。

-------

不要在需要字符串的时候使用字符（反之亦然）。

## 13.2 字符串变量

只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。

有时很难辨别是否把字符数组作为字符串来使用。如果编写自己的字符串处理函数，请千万注意要正确地处理空字符。而且，要确定字符串长度没有比逐个字符地搜索字符更快捷的方法了。

假设需要声明一个变量用来存储最多80个字符的字符串。由于字符串在末尾处需要有空字符，我们把变量声明为含有81个字符的数组：

```c
#define STR_LEN 80
...
char str[STR_LEN+1];
```

-------

当声明用于存放字符串的字符数组时，要始终保证数组的长度比字符串的长度多一个字符。这是因为C语言规定每个字符串都要以空字符结尾。如果没有给空字符预留位置，可能会导致程序运行时出现不可预知的结果，因为C函数库中的函数假设字符串都是以空字符结束的。

------

### 13.2.1 初始化字符串变量

字符串变量可以在声明时进行初始化：

```c
char date1[8] = "June 14";
```

编译器会把字符串`"June 14"`中的字符复制到数组`date1`中，然后追加一个空字符从而使`date1`可以作为字符串使用。

C编译器会把它看成是数组初始化式的缩写形式。实际上，我们可以看成：

```c
char date1[8] = {'J', 'u', 'n', 'e', ' ', '1', '4', '\0'};
```

如果初始化式太短以致不能填满字符串变量，在这种情况下，编译器会添加空字符。

C语言允许初始化式（不包括空字符）与变量有完全相同的长度，由于没有给空字符留空间，所以编译器不会试图存储空字符。

-----

如果正在计划对用来放置字符串的字符数组进行初始化，一定要确保数组的长度要长于初始化式的长度，否则，编译器将忽略空字符，这将使得数组无法作为字符串使用。

------

字符串变量的声明可以省略它的长度。这种情况下，编译器会自动计算长度：

```c
char date4[] = "June 14";
```

### 13.2.2 字符数组与字符指针

```c
char date[] = "June 14";
char *date = "June 14";
```

两者不能互换，它们之间有很大的差异：

- 在声明为数组时，就像任意数组元素一样，可以修改存储在`date`中的字符。在声明为指针时，`date`指向字符串字面量，字符串字面量是不可以修改的。
- 在声明数组时，`date`是数组名。在声明为指针时，`date`是变量，这个变量可以在程序执行期间指向其他字符串。

如果希望可以修改字符串，那么就要建立字符数组来存储字符串，声明指针变量是不够的。

```c
char str[STR_LEN+1], *p;
p = str;
```

## 13.3 字符串的读和写

为了一次性读入字符串，可以使用`scanf`函数或`gets`函数，也可以每次读入一个字符。

### 13.3.1 用`printf`函数和`puts`函数写字符串

转换说明`%s`允许`printf`函数写字符串。

```c
char str[] = "Are we having fun yet?";
printf("%s\n", str);
```

`printf`函数会逐个写字符串中的字符，直到遇到空字符才停止。（如果空字符丢失，`printf`函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。）

如果只想显示字符串的一部分，可以使用转换说明`%.ps`，这里的`p`是要显示的字符数量。

```c
printf("%.6s\n", str);
```

输出

```c
Are we
```

字符串跟数一样，可以在指定字段内显示。转换说明`%ms`会在大小为`m`的字段内显示字符串。（对于超过`m`的字符的字符串，`printf`函数会显示出整个字符串，而不会截断。）如果字符串少于`m`个字符，则会在字段内右对齐输出。如果要强制左对齐，可以在`m`前加一个减号。`m`值和`p`值可以组合使用：转换说明`%m.ps`会使字符串的前`p`个字符在大小为`m`的字段内显示。

C函数库还提供了`puts`函数来输出字符串。`puts`函数只有一个参数，即需要显示的字符串：

```c
puts(str);
```

### 13.3.2 用`scanf`函数和`gets`函数读字符串

转换说明`%s`允许`scanf`函数把字符串读入字符数组：

```c
scanf("%s", str);
```

在`scanf`函数调用中，不需要在`str`前添加运算符`&`，因为`str`是数组名，编译器在把它传递给函数时会把它当作指针来处理。

调用时，`scanf`函数会跳过空白字符，然后读入字符并存储到`str`中，直到遇到空白字符为止。 `scanf`函数始终会在字符串末尾存储一个空字符。

用`scanf`函数读入字符串永远不会包含空白字符。因此，`scanf`函数通常不会读入一整行输入。换行符会使`scanf`函数停止读入，空格符或制表符也会产生同样的结果。为了一次读入一整行输入，可以使用`gets`函数。

类似于`scanf`函数，`gets`函数把读入的字符放到数组中，然后存储一个空字符。然而，在其他方面`gets`函数有些不同于`scanf`函数。

- `gets`函数不会在开始读字符串之前跳过空白字符（`scanf`函数会跳过）。
- `gets`函数会持续读入直到找到换行符才停止（`scanf`函数会在任意空白字符处停止）。此外，`gets`函数会忽略掉换行符，不会把它存储到数组中，用空字符代替换行符。

-------

在把字符读入数组时，`scanf`函数和`gets`函数都无法检测数组何时被填满。因此，它们存储字符时可能越过边界，这会导致未定义的行为。通过用转换说明`%ns`代替 `%s`可以使`scanf`函数更安全。这里的数字`n`指出可以存储的最多字符数。

`gets`函数天生不安全，`fgets`函数则是一种好得多的选择。

--------

### 13.3.3 逐个字符读字符串

因为对许多程序而言，`scanf`函数和`gets`函数都有风险且不够灵活，C程序员经常会自己编写输入函数。通过每次一个字符的方式来读入字符串，这类函数可以提供比标准输入函数更大程度的控制。

如果决定设计自己的输入函数，那么就需要考虑下面这些问题。

- 在开始存储字符串之前，函数应该跳过空白字符吗？
- 什么字符会导致函数停止读取：换行符、任意空白字符还是其他某种字符？需要存储这类字符还是忽略掉？
- 如果输入的字符串太长以致无法存储，那么函数应该做些什么：忽略额外的字符还是把它们留给下一次输入操作？

```c
int read_line(char str[], int n)
{
  int ch; i = 0;
  
  while ((ch = getchar()) != '\n')
    if (i < n)
      str[i++] = ch;
  str[i] = '\0';						/* terminates strings */
  return i;									/* number of characters stored */
}
```



## 13.4 访问字符串中的字符

 字符串是以数组的方式存储的，因此可以使用下标来访问字符串中的字符。

- 只要使用方便，可以随意使用数组操作或指针操作访问字符串中的字符。
- 字符串形式参数声明为数组或指针，两者之间没有任何差异。
- 形式参数的形式（`s[]`或者`*s`）不会对实际参数产生影响。

## 13.5 使用C语言的字符串库

在C语言中把字符串当作数组来处理，因此对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。

直接复制或比较字符串会失败。

把数组名用作`=`的左操作数是非法的。但是，使用`=`初始化字符数组是合法的。

```c
char str1[10], str2[10];

str1 = "abc";			/*** WRONG ***/
str2 = str1;			/*** WRONG ***/

char srt1[10] = "abc";
```

C语言的函数库为完成对字符串的操作提供了丰富的函数集。这些函数的原型驻留在`<string.h>`头中

### 13.5.1 `strcpy`（String Copy）函数

`strcpy`函数在`<string.h>`中的原型如下：

```c
char *srtcpy(char *s1, const char *s2);
```

`strcpy`函数把字符串`s2`复制给字符串`s1`。（准确地讲，应该说成是“`strcpy`函数把`s2`指向的字符串复制到`s1`指向的数组中”。）

在`strcpy(str1, str2)`的调用中，`strcpy`函数无法检查`str2`指向的字符串的大小是否真的适合`str1`指向的数组。假设`str1`指向的字符串长度为$n$，如果`str2`指向的字符串中的字符数不超过$n-1$，那么复制操作可以完成。但是，如果`str2`指向更长的字符串，那么结果就无法预料了。（因为`strcpy`函数会一直复制到第一个空字符为止，所以它会越过`str1`指向的数组的边界继续复制。）

### 13.5.2 `strlen`（String Length）函数

`strlen`函数的原型（prototype）如下：

```c
size_t strlen (const char *s);
```

定义在C函数库中的`size_t`类型是一个`typedef`名字，表示C语言中的一种无符号整型。

`strlen`函数返回字符串`s`的长度：`s`中第一个空字符之前的字符个数（不包括空字符）。

```c
int len;

len = strlen("abc");			/* len is now 3 */
len = strlen(" ");				/* len is now 0 */
```

### 13.5.3 `strcat`(String Concatenation)函数

`strcat`函数的原型如下：

```c
char *strcat(char *s1, const char *s2);
```

`strcat`函数把字符串`s2`的内容追加到字符串`s1`的末尾，并且返回字符串`s1`（指向结果字符串的指针）。

```c
strcpy(str1, "abc");
strcpy(str1, "def");			/* str1 now contains "abcdef" */
```

如果`str1`指向的数组没有大到足以容纳`str2`指向的字符串中的字符，那么调用`strcat(str1, str2)`的结果将是不可预测的。

### 13.5.4 `strcmp`（String Comparison）函数

`strcmp`函数的原型如下：

```c
int strcmp(const char *s1, const char *s2);
```

`strcmp`函数比较字符串`s1`和字符串`s2`，然后根据`s1`是小于、等于或大于`s2`，函数返回一个小于、等于或大于0的值。

`strcmp`函数利用字典顺序进行字符串比较。更精确地说，只要满足下列两个条件之一，那么`strcmp`函数就认为`s1`是小于`s2`的。

- `s1`与`s2`的前$i$个字符一致，但是`s1`的第$i+1$个字符小于`s2`第$i+1$个字符。例如，`"abc"`小于`"bcd"`，`"abd"`小于`"abe"`。

- `s1`的所有字符与`s2`的字符一致，但是`s1`比`s2`短。例如，`"abc"`小于`"abcd"`。

  当比较两个字符串中的字符时，`strcmp`函数会查看字符对应的数值码。一些底层字符集的知识可以帮助预测`strcmp`函数的结果。

## 13.6 字符串惯用法（Idioms）



###13.6.1 搜索字符串的结尾

### 13.6.2 复制字符串

## 13.7 字符串数组

