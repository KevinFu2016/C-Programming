# Ch4 表达式

表达式：如何计算值的公式

最简单的表达式是变量和常量。变量表示程序运行时需要计算的值，常量表示不变的值，更加复杂的表达式把运算符用于操作数（操作数自身是表达式）。

在表达式`a+(b*c)`中，运算符+用于操作数`a`和`(b*c)`，而这两者自身又都是表达式



运算符是构建表达式的基本工具。

C语言提供的基本运算符：

**算术运算符**，包括加、减、乘和除；

**关系运算符**进行诸如”i比0大“这样的比较运算；

**逻辑运算符**实现诸如”i比0大并且i比10小“这样的关系运算。



本章内容

算术运算符

赋值运算符

自增及自减运算符

运算符的优先级和结合性

C语言表达式的求值方法

表达式语句，一种允许把任何表达式都当作语句来使用的特性

## 4.1 算数运算符

算术运算符是包括C语言在内的许多编程语言中都广泛应用的一种运算符，这类运算符可以执行加法、减法、乘法和除法。

|    一元运算符     |  二元运算符   |               |
| :---------------: | :-----------: | :-----------: |
|                   |    加法类     |    乘法类     |
| `+`一元正号运算符 | `+`加法运算符 | `*`乘法运算符 |
| `-`一元负号运算符 | `-`减法运算符 | `/`除法运算符 |
|                   |               | `%`求余运算符 |

运算符`/`和运算符`%`需要特别注意一下几点。

运算符`/`可能产生意外的结果。当两个操作数都是整数时，运算符`/`会丢掉分数部分来“截取”结果。因此`1 / 2`的结果是0而不是0.5。

运算符`%`要求操作数是整数。如果两个操作数中有一个不是整数，程序将无法编译通过。

把零用作`/`和`%`的右操作数会导致未定义的行为。

当运算符`/`和运算符`%`用于负操作数时，其结果难以确定。根据C89标准，如果两个操作数中有一个为负数，那么除法的结果结果既可以向上取整也可以向下取整。在C89中，如果`i`或者`j`是负数，`i%j`的符号与具体实现有关。但是在C99中，除法的结果总是向零截取的，`i%j`的值的符号与`i`的相同。



**运算符的优先级和结合性**

C语言采用***运算符优先级***（operator precedence）规则来解决隐含的二义性问题。算术运算符的相对优先级如下：

最高优先级：`+`	`-`（一元运算符）

​					   `*`	`/`	`%`

最低优先级：`+`	`-` （二元运算符）

当两个或更多个运算符出现在同一个表达式时，可以通过按运算符优先级从高到低的次序重复给子表达式添加圆括号来确定编译器解释表达式的方法。

`i + j * k`	等价于	`i + ( j * k )`

`-i * -j`	等价于	`(-i) * (-j)`

`+i + j / k`	等价于	`(+i) + ( j / k )`

当表达式包含两个或更多个相同优先级时，仅有运算符优先级规则是不够用的。这种情况下，运算符的***结合性***（associativity）开始发挥作用。如果运算符是从左向右结合的，那么称这种运算符是***左结合的***（left accociative）。二元算术运算符（即`*`、`/`、`%`、`+`和`-`）都是左结合的。

`i - j - k`	等价于	`( i - j ) - k`

`i * j / k`	等价于	`( i * j ) / k`  

如果运算符是从右向左结合的，那么称这种运算符是***右结合的***（right associative）。一元运算符（`+`和`-`）都是右结合的。

## 4.2 赋值运算符

 求出表达式的值以后常常需要将其存储到变量中，以便将来使用。C语言的`=`（简单赋值（simple assignment））运算符可以用于此目的。为了更新已经存储在变量中的值，C语言还提供了一种复合赋值（compound assignment）运算符。

### 4.2.1 简单赋值

表达式`v=e`的赋值效果是求出表达式`e`的值，并把此值复制给`v`。如下面的例子所示，`e`可以是常量、变量或更为复杂的表达式：

```c
i = 5;					/* i is now 5  */
j = i;					/* j is now 5  */
k = 10 * i + j;	/* k is now 55 */
```

如果v和e的类型不同，那么赋值运算发生时会把`e`的值转化为`v`的类型

```c
int i;
float f;

i = 72.99f;	/* i is now 72  */
f = 136;		/* f is now 136 */
```

在C语言中，赋值就像`+`那样是运算符。换句话说，赋值操作产生结果，这就如同两个数相加产生结果一样。赋值表达式`v=e`的值就是赋值运算后`v`的值。

-----

副作用

大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用（side effect）。

-----

### 4.2.2 左值

大多数C语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，赋值运算符要求它的左操作数必须是***左值***（lvalue）。左值表示存储在计算机内存中的对象，而不是常量或计算的结果。变量是左值，而诸如10或`2 * i`这样的表达式则不是左值。

既然赋值运算符要求左操作数是左值，那么在赋值表达式的左侧放置任何其他类型的表达式都是不合法的：

```c
12 = i;			/*** WRONG ***/
i + j = 0;	/*** WRONG ***/
-i = j;			/*** WRONG ***/
```

### 4.2.3 复合赋值

C语言的复合赋值运算符允许缩短`i = i + 2;`这个语句以及类似的语句。使用`+=`运算符，可以将其表达式简写为

```c
i += 2; 	/* same as i = i + 2; */
```

`+=`运算符把右操作数的值加到左侧的变量中去。

还有另外9种复合赋值运算符，包括

`-=`	`*=`	`/=`	`%=`

所有复合赋值运算符的工作原理大体相同。

​	`v += e`表示`v`加上`e`，然后将结果存储到`v`中。

​	`v -= e`表示`v`减去`e`，然后将结果存储到`v`中。

​	`v *= e`表示`v`乘以`e`，然后将结果存储到`v`中。

​	`v /= e`表示`v`除以`e`，然后将结果存储到`v`中。

​	`v %= e`表示`v`除以`e`取余数，然后将结果存储到`v`中。

注意，这里没有说`v += e` “等价于” `v = v + e`。一个问题是运算符的优先级：表达式`i *= j + k`和表达式`i = i * j + k`是不一样的。在极少数情况下，由于`v`自身的副作用，`v += e`也不等同于`v = v + e`。类似的说明也适用于其他赋值运算符。

复合赋值运算符有着和`=`运算符一样的特性。特别是，它们都是右结合的，所以语句

```C
i += j += k;
```

意味着

```c
i += (j += k);
```

## 4.3 自增运算符和自减运算符

```c
i = i + 1;
j = j - 1;
```

复合赋值运算符可以将上述这些语句缩短些

```c 
i += 1;
j -= 1;
```

C语言允许使用`++`（***自增***）和`--`（***自减***）运算符缩短以上语句。

自增和自减运算符的使用是很复杂的。原因之一是，`++`和`--`运算符既可以作为***前缀***（prefix）运算符（如`++i`和`--i`）使用也可以作为***后缀***（postfix）运算符（如i++和`i--`）使用。程序的正确性可能和选取适合的运算符形式紧密相关。

另一个原因是，和赋值运算符一样，`++`和`--`也有副作用：它们会改变操作数的值。计算表达式`++i`（“前缀自增”）的结果是`i+1`，而副作用的效果是自增`i`：

```c
i = 1;
printf("i is %d\n", ++i);		/* prints "i is 2" */
printf("i is %d\n", i);			/* prints "i is 2" */
```

计算表达式`i++`（“后缀自增”）的结果是`i`，但是会引发`i`随后进行自增：

```c
i = 1;
printf("i is %d\n", i++);		/* prints "i is 1" */
printf("i is %d\n", i);			/* prints "i is 2" */
```

 第一个`printf`函数显示了`i`自增前的原始值，第二个`printf`函数显示了i变化后的新值。正如这些例子说明的那样，`++i`意味着“立即自增i”，而`i++`则意味着“现在先用i的原始值，稍后再自增`i`”。这个“稍后”有多久呢？C语言标准没有精确的时间，但是可以放心地假设`i`将在下一条语句执行前进行自增。

`--`运算符具有相似的特性：

```c
i = 1;
printf("i is %d\n", --i);		/* prints "i is 0" */
printf("i is %d\n", i);			/* prints "i is 0" */

i = 1;
printf("i is %d\n", i--);		/* prints "i is 1" */
printf("i is %d\n", i);			/* prints "i is 0" */
```



需要记住的是，后缀`++`和后缀`--`比一元的正号、负号优先级高，而且都是左结合的。前缀`++`和前缀`--`与一元的正号、负号优先级相同，而且都是右结合的。

## 4.4 表达式求值

假设我们读某人的程序时遇到类似这样的复杂表达式：

```c 
a = b += c++ - d + --e / -f
```

如果有圆括号显示表达式是如何由子表达式构成的，那么这个复杂的表达式将较容易理解。借助运算符优先级表，为表达式添加圆括号是非常容易的：检查表达式，找到最高优先级的运算符后，用圆括号把运算符和相应的操作数括起来，这表明在此之后圆括号内的内容将被看成是一个单独的操作数。然后重复此类操作直到将表达式完全加上圆括号。

**子表达式的求值顺序**

有了运算符的优先级和结合性规则我们可以将任何C语言表达式划分成子表达式；如果表达式是完全括号化的，那么这些规则还可以唯一确定添加圆括号的方式。与之相矛盾的是，这些规则并不总是允许我们确定表达式的值，表达式的值可能依赖于子表达式的求值顺序。

--------

**未定义行为**

根据C标准，类似`c = (b = a + 2) - (a = 1);`和`j = i * i++;`这样的语句都会导致“未定义行为”（undefined behavior），当程序中出现未定义的行为时，后果是不可预料的。不同的编译器给出的编译结果可能是不同的，但这还不是唯一可能发生的事情：首先程序可能无法通过编译，就算通过了编译也可能无法运行，就算可以运行也有可能崩溃、不稳定或者产生无意义的结果。换句话说，应该像躲避瘟疫一样避免未定义的行为。

-------



## 4.5 表达式语句

C语言有一条不同寻常的规则，那就是任何表达式都可以用作语句。换句话说，不论表达式是什么类型，计算什么结果，我们都可以通过在后面添加分号的方式将其转换成语句。

