# Ch5 选择语句

尽管C语言有许多运算符，但是它所拥有的语句却相对较少。到目前为止，我们只见过两种语句：`return`语句和表达式语句。根据语句执行顺序的影响，C语言的其余语句大多属于以下3大类：

**选择语句**（selection statement）。`if`语句和`switch`语句允许程序在一组可选项中选择一条特定的执行路径。

重复语句（iteration statement）。`while`语句、`do`语句和`for`语句支持重复（循环）操作。

跳转语句（jump statement）。`break`语句、`continue`语句和`goto`语句导致无条件地跳转到程序中的某个位置。（`return`语句也属于此类）

C语言还有其他两类语句，一类是复合语句（把几条语句组合成一条语句），一类是空语句（不执行任何操作）。



本章内容

选择语句和复合语句

逻辑表达式：`if`语句可以测试的条件

关系运算符（`<`、`<=`、>和`>=`）、判等运算符（`==`和`!=`）和逻辑运算符（`&&`、`||`和`!`）构造逻辑表达式

`if`语句和复合语句，以及可以在一个表达式内测试条件的条件运算符（`?:`）

`switch`语句

## 5.1 逻辑表达式

包括if在内的某些C语句都必须测试表达式的值是“真”还是“假”。例如，`if`语句可能需要检测表达式`i < j`，真值将说明`i`是小于`j`的。

在C语言中，诸如`i < j`这样的比较会产生整数：0（假）或1（真）。

### 5.1.1 关系运算符

C语言的***关系运算符***（relational operator）和数学上的$\lt$、$\gt$、$\le$和$\ge$运算符相对应，只是用在C语言的表达式中时产生的结果是0（假）或1（真）。

关系运算符可以用于比较整数和浮点数，也允许比较混合类型的操作数。

|  符号  |   含义   |
| :----: | :------: |
| $\lt$  |   小于   |
| $\gt$  |   大于   |
| $\lt=$ | 小于等于 |
| $\gt=$ | 大于等于 |

关系运算符的优先级低于算术运算符。例如，表达式`i + j < k - 1`意思是`(i + j) < (k - 1)`。关系运算符都是左结合的。

### 5.1.2 判等运算符

C语言中的***判等运算符***（equality operator）

| 符号 |  含义  |
| :--: | :----: |
| `==` |  等于  |
| `!=` | 不等于 |

和关系运算符一样，判等运算符也是左结合的，也是产生0（假）或1（真）作为结果。然而，判等运算符的优先级低于关系运算符。例如，表达式`i < j == j < k`等价于表达式`(i < j) == (j < k)`。如果`i < j`和`j < k`的结果为同为真或同为假，那么这个表达式的结果为真。

### 5.1.3 逻辑运算符

利用***逻辑运算符***（logical operator）“与”、“或”和“非”，较简单的表达式可以构建出更加复杂的逻辑表达式。`!`是一元运算符，而`&&`和`||`是二元运算符。

| 符号 |  含义  |
| :--: | :----: |
| `!`  | 逻辑非 |
| `&&` | 逻辑与 |
| `||` | 逻辑或 |

逻辑运算符所产生的结果是0或1.操作数的值经常是0或1，但这不是必需的。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何操作数作为假值来处理。

逻辑运算符的操作如下：

- 如果*expr*的值为0，那么`!expr`的结果为1；
- 如果*expr1*和*expr2*的值都是非零值，那么`expr1&&expr2`的结果为1；
- 如果*expr1*或*expr2*的值中任意一个是（或者两者都是）非零值，那么`expr1||expr2`的结果为1。

在所有其他情况下，这些运算符产生的结果都为0。

运算符`&&`和运算符`||`都对操作数进行“短路（short-circuit）“计算。也就是说，这些运算符首先计算出左操作数的值，然后计算右操作数；如果表达式的值可以仅由左操作数的值推导出来，那么将不计算右操作数的值。如果没有短路计算，那么表达式的求值将会导致除以零的运算。

运算符`!`的优先级和一元正负号的优先级相同，运算符`&&`和运算符`||`的优先级低于关系运算符和判等运算符。

## 5.2 `if`语句

`if`语句允许程序通过测试表达式的值从两种选项中选择一种。`if`语句的最简单格式如下：

```c
if (expression) statment
```

执行`if`语句时，先计算圆括号内表达式的值。如果表达式的值非零（C语言把非零值解释为真值），那么接着执行圆括号后边的语句。

### 5.2.1 复合语句

如果想用`if`语句处理两条或更多条语句，可以引入***复合语句***（compound statement）。复合语句格式如下：

```c
{ statements }
```

### 5.2.2 `else`子句

`if`语句可以有`else`子句：

```c
if ( expression ) statement else statement
```

如果圆括号内的表达式的值为0，那么就执行else后边的语句。

### 5.2.3 级联式`if`语句

编程时常常需要判定一系列的条件，一旦其中某一条件为真就立刻停止。“级联式”`if`语句常常是编写这类系列判定的最好方法。

```c
if ( expression )
  statement
else if ( expression )
  statement
...
else if ( expression )
  statement
else
  statement
```

当然，这种格式中的最后两行（`else`语句）不是总出现。这种缩进级联式`if`语句的方法避免了判定数量过多时过度缩进的问题。此外，这样也向读者证明了这组语句只是一连串的判定。

### 5.2.4 “悬空`else`”的问题

```c
if (y != 0)
  if (x != 0)
    result = x / y;
else
  printf("Error: y is equal to 0\n");
```

C语言遵循的规则是`else`子句应该属于离它最近的且还未和其他`else`匹配的`if`语句。在此例中，`else`子句实际上属于最内层的`if`语句，所以正确的缩进格式应该如下所示：

```c
if (y != 0)
  if (x != 0)
    result = x / y;
	else
  printf("Error: y is equal to 0\n");
```

为了使`else`子句属于外层的`if`语句，可以把内层的`if`语句用花括号括起来：

```c
if (y != 0) {
  if (x != 0)
    result = x / y;
}	else
  printf("Error: y is equal to 0\n");
```

### 5.2.5 条件表达式

***条件运算符***（conditional operator）是由符号`?`和符号`:`组成，两个符号必须按如下格式一起使用：

```c
expr1 ? expr2 : expr3
```

`expr1`、`expr2`和`expr3`可以是任何类型的表达式，按上述方式组合成的表达式称为***条件表达式***（conditional expression）。条件运算符是C运算符中唯一一个要求3个操作符的运算符。因此，经常把它称为***三元***（ternary）运算符。

应该把条件表达式`expr1 ? expr2 : expr3`读作“if `expr1` then `expr2` else `expr3`“条件表达式求值的步骤是：首先计算出`expr1`的值，如果此值不为零，那么计算`expr2`的值，并且计算出来的值就是整个条件表达式的值；如果`expr1`的值为零，那么`expr3`的值是整个条件表达式的值。

### 5.2.6 C89中的布尔值

多年以来，C语言一直缺乏适当的布尔类型，C89标准中也没有定义布尔类型。因为许多程序需要变量能存储假或真值，缺少布尔类型可能会有点麻烦。针对C89的这一限制，一种解决方法是先声明一个`int`变量，然后将其赋值为0或1:

```c
int flag;

flag = 0;
...
flag = 1;
```

 虽然这种方法可行，但是它对于程序的可读性没有多大贡献，因为没有明确地表示`flag`的赋值只能是布尔值，并且也没有明确指出0和1就是表示假和真。

为了使程序更加便于理解，C89的程序员通常使用`TRUE`和`FLASE`这样的名字定义宏：

```c
#define TRUE 1
#define FLASE 0
```

现在对`flag`对赋值有了更加自然的形式：

```c
flag = FALSE;
...
flag = TRUE;
```

为了判定`flag`是否为真，可以用

```c
if (flag == TRUE) ...
```

或者只写

```c
if (flag) ...
```

为了判定`flag`是否为假，可以用

```c
if (flag == FALSE) ...
```

或者

```c
if (!flag)
```

为了发扬这一思想，甚至可以定义一个可用作类型的宏：

```c
#define BOOL int
```

声明布尔型变量时可以用`BOOL`代替`int`：

```c
BOOL flag；
```

现在就非常清楚`flag`不是普通的整型变量，而是表示布尔条件。（当然，编译器仍然把`flag`看成是`int`型变量。）

### 5.2.7 C99中的布尔值(C99)

C99提供了`_Bool`型，所以在C语言的这一版本中，布尔变量可以声明为：

```c
_Bool flag;
```

`_Bool`是整数类型（更准确地说是无符号整型），所以 `_Bool`变量实际上就是整型变量；但是和一般整型不同，`_Bool`只能赋值为0或1。一般来说，往`_Bool`变量中存储非零值会导致变量赋值为1:

```c
flag = 5;		/* flag is assigned 1 */
```

对于`_Bool`变量来说，算术运算是合法的（不过不建议这样做），它的值也可以进行打印（显示0或者1）。当然，`_Bool`变量也可以在`if`语句中测试：

```c
if (flag)		/* tests whether flag is 1 */
 ...
```

除了`_Bool`类型的定义，C99还提供了一个新的头`<stdbool.h>`，这使得操作布尔值更加容易。该头提供了`bool`宏，用来代表`_Bool`。如果程序中包含了`<stdbool.h>` ，可以这样写：

```c
bool flag;	/* same as _Bool flag; */
```

`<stdbool.h>`头还提供了`true`和`false`两个宏，分别代表1和0。于是可以写

```c
flag = false;
...
flag = true;
```

### 5.3 `switch`语句

在日常编程中，常常需要把表达式和一系列值进行比较，从中找出当前匹配的值。C语言提供了`switch`语句作为级联式`if` 语句的替换。

`switch`语句往往比级联式`if`语句更容易阅读。此外，`switch`语句往往比`if`语句执行速度快，特别是在有许多情况要判定的时候。

`switch`语句的最常用格式如下：

```c
switch ( expression ) {
  case constant-expression : statements
  ...
  case constant-expression : statements
  default : statements
}
```

- **控制表达式**。`switch`后边必须跟着由圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此在`switch`语句中可以对字符进行判定。但是，不能用浮点数和字符串。

- **分支标号**。每个分支的开头都有一个标号，格式如下：

  ```c
  case constant-expression;
  ```

  **常量表达式**（constant expression）很像是普通的表达式，只是不能包含变量和函数调用。因此，`5`是常量表达式，`5 + 10`也是常量表达式，但`n + 10`不是常量表达式（除非`n`是表示常量的宏）。分支标号中的常量表达式的值必须是整数（字符也可以）。

- **语句**。每个分支标号的后边可以跟任意数量的语句。不需要用花括号把这些语句括起来。每组语句的最后一条通常是`break`语句。

C语言不允许有重复的分支标号，但对分支的顺序没有要求，特别是`default`分支不一定要放置在最后。

`switch`语句不要求一定有`default`分支。如果`default`不存在，而且控制表达式的值和任何一个分支标号都不匹配的话，控制会直接传给`switch`语句后面的语句。

**break语句的作用**

执行`break`语句会导致程序“跳”出`switch`语句，继续执行`switch`后面的语句。

需要`break`语句是由于`switch`语句实际上是一种“基于计算的跳转”。对控制表达式求值时，控制会跳转到`switch`表达式的值相匹配的分支标号处。分支标号只是一个说明`switch`内部位置的标记。在执行完分支中的最后一条语句后，程序控制“向下跳转”到下一个分支的第一条语句上，而忽略下一个分支的分支标号。如果没有`break`语句（或者其他某种跳转语句），控制将会从一个分支继续到下一个分支。
