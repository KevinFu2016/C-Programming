# Ch7 基本类型

本章内容

整数类型的取值范围，包括长整型、短整型和无符号整型

`double`和`long double`类型

`char`（字符）类型，用于字符处理

类型转换，把一种类型的值转换成另外一种类型的等价值

`typedef`定义新类型名

`sizeof`运算符，用来计算一种类型需要的存储空间大小

## 7.1 整数类型

***整数类型***（integer type）的值是整数（whole numbers），整数类型分为两大类：有符号型和无符号型（signed and unsigned）。

C语言的整数类型有不同尺寸。`int`类型通常为32位，但在老的CPU上可能是16位。有些程序所需的数很大，无法以`int`类型存储，所以C语言还提供了长整型。某些时候，为了节省空间，我们会指示编译器以比正常存储小的空间来存储一些数，称这样的数为短整型。

为了使构造的整数类型正号满足需要，可以把说明符组合起来。

```c
short int
unsigned short int

int 
unsigned int

long int
unsigned long int
```

C语言允许通过省略单词`int`来缩写整数类型的名字。例如，`unsigned short int`可以缩写为`unsigned short`，而`long int`则可以缩写为`long`。

6种整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则。首先，C标准要求`short int`、`int`和`long int`中的每一种类型都要覆盖一个确定的最小取值范围。其次，标准要求`int`类型不能比`short int`类型短，`long int`类型不能比`int`类型短。但是，`short int`类型的取值范围有可能和`int`类型的范围是一样的，`int`类型的取值范围也可以和`long int`的一样。

<center><font face="黑体" size = 4>16位机的整数类型</center></font>

| 类型                 |         最小值 |        最大值 |
| :------------------- | -------------: | ------------: |
| `short int`          |        -32 768 |        32 767 |
| `unsigned short int` |              0 |        65 535 |
| `int`                |        -32 768 |        32 767 |
| `unsigned int`       |              0 |        65 535 |
| `long int`           | -2 147 483 648 | 2 147 483 647 |
| `unsigned long int`  |              0 | 4 294 967 295 |

<center><font face="黑体" size = 4>32位机的整数类型</center></font>

| 类型                 |         最小值 |        最大值 |
| :------------------- | -------------: | ------------: |
| `short int`          |        -32 768 |        32 767 |
| `unsigned short int` |              0 |        65 535 |
| `int`                | -2 147 483 648 | 2 147 483 647 |
| `unsigned int`       |              0 | 4 294 967 295 |
| `long int`           | -2 147 483 648 | 2 147 483 647 |
| `unsigned long int`  |              0 | 4 294 967 295 |

<center><font face="黑体" size = 4>64位机的整数类型</center></font>

| 类型                 |                     最小值 |                     最大值 |
| :------------------- | -------------------------: | -------------------------: |
| `short int`          |                    -32 768 |                     32 767 |
| `unsigned short int` |                          0 |                     65 535 |
| `int`                |             -2 147 483 648 |              2 147 483 647 |
| `unsigned int`       |                          0 |              4 294 967 295 |
| `long int`           | -9 223 372 036 854 775 808 |  9 223 372 036 854 775 807 |
| `unsigned long int`  |                          0 | 18 446 744 073 709 551 615 |

表中给出的取值范围不是C标准强制的，会随着编译器的不同而不同。对于特定的实现，确定整数类型范围的一种方法是检查`<limits.h>`头。该头是标准库的一部分，其中定义了表示每种整数类型的最大值和最小值的宏。

### 7.1.1 C99中的整数类型（C99）

C99提供了两个额外的标准整数类型：`long long int`和`unsigned long long int`。增加这两种整数类型有两个原因，一是为了满足日益增长的对超大型整数的需求，二是为了适应支持64位运算的新处理器的能力。这两个`long long`类型要求至少64位宽，所以`long long int`类型值的范围通常为$-2^{63}$到$2^{63}-1$，而`unsigned long long int`类型值的范围通常为0到$2^{64}-1$。

C99中把`short int`、`int`、`long int`和`long long int`类型（以及`signed char`类型）称为***标准有符号整型***（standard signed integer types），而把`unsigned short int`、`unsigned int`、`unsigned long int`和`unsigned long long int`类型（以及`unsigned char`类型和`_Bool`类型）称为***标准无符号整型***（standard unsigned integer types）。

除了标准的整数类型以外，C99标准还允许在具体实现时定义***扩展的整数类型***（包括有符号的和无符号的）（extended integer types）。例如，编译器可以提供有符号和无符号的128位整数类型。

### 7.1.2 整数常量

C语言允许使用十进制（基数为10）、八进制（基数为8）和十六进制（基数为16）形式书写整数常量。

-  十进制常量包含0~9中的数字，但是一定不能以零开头

  `15`	`255`	`32767`

- 八进制常量只包含0~7中的数字，而且必须以零开头

  `017`	`0377`	`077777`

- 十六进制常量包含0~9中的数字和a~f中的字母，而且总是以`0x`开头

  `0xf`	`0xff`	`0x7fff`

  十六进制常量中的字母既可以是大写字母也可以是小写字母：

  `0xff`	`0xfF`	`0xFF`	`0Xff`	`0XfF`	`0XFf`	`0XFF`

八进制和十六进制只是书写数的方式，它们不会对数的实际存储方式产生影响。（整数都是以二进制形式存储的，跟表示方式无关。）

为了强制编译器把常量作为长整数来处理，只需在后边加上一个字母`L`（或`l`）：

`15L`	`0377L`	`0x7fffL`

为了指明是无符号常量，可以在常量后边加上字母`U`（或`u`）：

`15U`	`0377U`	`0x7fffU`

`L`和`U`可以结合使用，以表明常量既是长整型又是无符号的：`0xffffffffUL`。（字母`L`、`U`的顺序和大小写无所谓。）

### 7.1.3 C99中的整数常量（C99）

在C99中，以`LL`或`ll`（两个字母大小写要一致）结尾的整数常量是`long long int`型的。

C99确定整数常量类型的规则与C89有些不同。对于没有后缀的十进制常量，其类型是`int`、`long int`或`long long int`中能表示该值的“最小”类型。对于八进制或者十六进制常量，可能的类型顺序为`int`、`unsigned int`、`long int`、`unsigned long int`、`long long int`和`unsigned long long int`。

常量后面的任何后缀都会改变可能类型的列表。

如果常量的数值过大以至不能用标准的整数类型表示，则可以使用扩展的整数类型。

### 7.1.4 整数溢出

对整数执行算术运算时，其结果有可能因为太大而无法表示。例如，对两个`int`值进行算术运算时，结果必须仍然能用`int`类型来表示，否则（表示结果所需的位数太多）就会发生溢出。

整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。有符号整数运算中发生溢出时，程序的行为是未定义的。未定义行为的结果是不确定的。最可能的情况是，仅仅是运算的结果出错了，但程序也有可能崩溃，或出现其他意想不到的情况。

无符号整数运算过程中发生溢出时，结果是有定义的：正确答案对$2^n$取模，其中$n$是用于存储结果的位数。例如，如果对无符号的16位数65 535加1，其结果可以保证为0。

### 7.1.5 读/写整数

假设有一个程序因为其中一个`int`变量发生了“溢出”而无法工作。我们的第一反应是把变量从`int`变为`long int`。但仅仅这样做是不够的，我们还必须检查数据类型的改变对程序其他部分的影响，尤其是需要检查该变量是否用在`printf`函数或`scanf`函数的调用中。如果用了，需要改变调用中的格式串，因为`%d`只适用于`int`类型。

读写无符号整数、短整数和长整数需要一些新的转换说明符。

- 读写无符号整数时，使用字母`u`、`o`或`x`代替转换说明中的`d` 。如果使用`u`说明符，该数将以十进制形式读写，`o`表示八进制形式，而`x`表示十六进制形式。

  ```c
  unsigned int u;
  
  scanf("%u", &u);		/* reads u in base 10 */
  printf("%u", u);		/* writes u in base 10 */
  scanf("%o", &u);		/* reads u in base 8 */
  printf("%o", u);		/* writes u in base 8 */
  scanf("%x", &u);		/* reads u in base 16 */
  printf("%x", u);		/* writes u in base 16 */
  ```

- 读写短整数时，在`d`、`o`、`u`或`x`前面加上字母`h`：

  ```c
  short s;
  
  scanf("%hd", &s);
  printf("%hd", s);
  ```

- 读写长整数时，在`d`、`o`、`u`或`x`前面加上字母`l`：

  ```c
  long l;
  
  scanf("%ld", &l);
  printf("%ld", l);
  ```

- （C99）读写长长整数时，在`d`、`o`、`u`或`x`前面加上字母`ll`：

  ```c
  long long ll;
  
  scanf("%lld", %ll);
  printf("%lld", ll);
  ```

## 7.2 浮点类型

整数类型并不适用于所有应用。有些时候需要变量能存储带小数点的数，或者能存储极大数或极小数。这类型可以用浮点（因小数点是“浮动的”而得名）格式进行存储。C语言提供了3种***浮点类型***（floating types），对应三种不同的浮点格式。

- `float`：单精度浮点数。
- `double`：双精度浮点数。
- `long double`：扩展精度浮点数。

C标准没有说明`float`、`double`和`long double`类型提供的精度到底是多少，因为不同的计算机可以用不同方法存储浮点数。大多数现代计算机都遵循IEEE 754标准（即IEC 60559）的规范。

下表给出了根据IEEE标准实现时浮点类型的特征。（表中给出了规范化的最小正值，非规范化的数可以更小。）`long double`类型没有显示在此表中，因为它的长度随着机器的不同而变化，而最常见的大小是80位和128位。

<center><font face = "黑体" size = 4>浮点类型的特征（IEEE标准）</font></center>

| 类型     | 最小正值                 | 最大值                  | 精度     |
| -------- | ------------------------ | ----------------------- | -------- |
| `float`  | $1.17549\times10^{-38}$  | $3.40282\times10^{38}$  | 6个数字  |
| `double` | $2.22507\times10^{-308}$ | $1.79769\times10^{308}$ | 15个数字 |

在不遵循IEEE标准的计算机上，上表是无效的。事实上，在一些机器上，`float`可以有和`double`相同的数值结合，或者`double`可以有和`long double`相同的数值集合。可以在头`<float.h>`中找到定义浮点类型特征的宏。

（C99）在C99中，浮点类型分为两种：一种是***实浮点类型***（real floating types），包括`float`、`double`和`long double`类型；另一种是C99新增的***复数类型***（complex types）（包括`float_Complex`、`double_Complex`和`long double_Complex`）。

### 7.2.1 浮点常量

浮点常量可以有许多种书写方式。例如，下面这些常量全部是表示数`57.0`的有效方式：

`57.0`	`57.`	`57.0e0`	`57E0`	`57e1`	`5.7e1`	`.57e2`	`570.e-1`

浮点常量必须包含小数点或指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。如果有指数，需要在指数数值前放置字母`E`（或者`e`）。可选符号`+`或`-`可以出现在字母`E`（或`e`)的后边。

默认情况下，浮点常量都以双精度数的形式存储。换句话说，当C语言编译器在程序中发现常量`57.0`时，它会安排数据以`double`类型变量的格式存储在内存中。这条规则通常不会引发任何问题，因为在需要时`double`类型的值可以自动转换为`float`类型的值。

在某些极个别的情况下，可能会需要强制编译器以 `float`或`long double`格式存储浮点常量。为了表明只需要单精度，可以在常量的末尾处加上字母`F`或`f`；而为了说明常量必须以`long double`格式存储，可以在常量的末尾处加上字母`L`或`l`。

（C99）C99提供了十六进制浮点常量的书写规范。十六进制浮点常量以`0x`或`0X`开头。

### 7.2.2 读/写浮点数

读取`double`类型的值时，在`e`、`f`或`g`前放置字母`l`：

```c
double d;
scanf("%lf", &d);
```

注意：只能在`scanf`函数格式串中使用`l`，不能在`printf`函数格式串中使用。在`printf`函数格式串中，转换`e`、`f`和`g`可以用来写`float`类型或`double`类型的值。

读写`long double`类型的值时，在`e`、`f`或`g`前放置字母`L`：

```c
long double ld;

scanf("%Lf", &ld);
printf("%Lf", ld);
```

## 7.3 字符类型

`char`类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。

`char`类型的变量可以用任意单字符赋值：

```c
char ch;

ch = 'a';		/* lower-case a */
ch = 'A';		/* upper-case A */
ch = '0';		/* zero					*/
ch = ' ';		/* space				*/
```

注意，字符常量需要用单引号括起来，而不是双引号。

### 7.3.1 字符操作

C语言把字符当作小整数进行处理。毕竟所有字符都是以二进制的形式进行编码的，而且无需花费太多的想象就可以将这些二进制代码看成整数。例如，在ACII码中取值范围是0000000~1111111，可以看成是0~127的整数。在C中，字符和整数之间的关联是非常强的，字符常量事实上是`int`类型而不是`char`类型。

当计算中出现字符时，C语言只是使用它对应的整数值。

```c
char ch;
int i;

i = 'a';			/* i is now 97   */
ch = 65;			/* ch is now 'A' */
ch = ch + 1;	/* ch is now 'B' */
ch++;					/* ch is now 'C' */
```

可以像比较数那样对字符进行比较。下面的`if`语句测试`ch`中是否含有小写字母，如果有，那么它会把`ch`转换为相应的大写字母。

```c
if ('a' <= ch && ch <= 'z')
  ch = ch - 'a' + 'A';
```

字符拥有和数相同的属性，这一事实会带来一些好处。例如，可以让`for`语句中的控制变量遍历所有的大写字母：

```c
for (ch = 'A'; ch <= 'Z'; ch++) ...
```

另一方面，以数的方式处理字符可能会导致编译器无法检查出来的多种编程错误，还可能会导致我们编写出诸如`'a' * 'b' / 'c'`这类无意义的表达式。此外，这样做也可能会妨碍程序的可移植性，因为程序可能会基于一些对字符集的假设。

### 7.3.2 有符号字符和无符号字符

`char`类型和整数类型一样也存在有符号型和无符号型两种。通常有符号字符的取值范围是-128~127，而无符号字符的取值范围则是0~255。

标准C允许使用单词`signed`和`unsigned`来修饰`char` 类型：

```c
signed char sch;
unsigned char uch;
```

可移植性技巧	不要假设`char`类型默认为`signed`或`unsigned`。如果有区别，用`signed char`或`unsigned char`代替`char`。

由于字符和整数之间有密切关系，C89采用术语***整值类型***（integral type）来（统称）包含整数类型和字符类型。枚举类型也属于整值类型。

C99不使用属于“整值类型”，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99中的`_Bool`型是无符号整数类型。

### 7.3.3 算术类型

整数类型和浮点类型统称为算术类型（arithmetic types）。下面对C89中的算术类型进行了总结分类。

- 整数类型：
  - 字符类型（`char`）；
  - 有符号整型（`signed char`、`short int`、`int`、`long int`）；
  - 无符号整型（`unsigned char`、`unsigned short int`、`unsigned int`、`unsigned long int`）；
  - 枚举类型。

- 浮点类型（`float`、`double`、`long double`）。

C99的算术类型具有更复杂的层次。

- 整数类型：
  - 字符类型（`char`）；
  - 有符号整型，包括标准的（`signed char`、`short int`、`int`、`long int`、`long long int`）和扩展的；
  - 无符号整型，包括标准的（`unsigned char`、`unsigned short int`、`unsigned int`、`unsigned long int`、`unsigned long long int`、`_Bool`）和扩展的；
  - 枚举类型。

- 浮点类型：
  - 实数浮点类型（`float`、`double`、`long double`）；
  - 复数类型（`float_Complex`、`double_Complex`、`long double_Complex`）。

### 7.3.4 转义序列

为了使程序可以处理字符集中的每一个字符，C语言提供了一种特殊的表示法——***转义序列***（escape sequence）。

转义序列有两种：***字符转义序列***（character escape）和***数字转义序列***（numeric escape）

<center><font face ="黑体" size =4>字符转义序列</font></center>

| 名称           | 转义序列 | 名称       | 转义序列 |
| -------------- | -------- | ---------- | -------- |
| 警报（响铃）符 | `\a`     | 垂直制表符 | `\v`     |
| 回退符         | `\b`     | 反斜杠     | `\\`     |
| 换页符         | `\f`     | 问号       | `\?`     |
| 换行符         | `\n`     | 单引号     | `\'`     |
| 回车符         | `\r`     | 双引号     | `\"`     |
| 水平制表符     | `\t`     |            |          |

为了把特殊字符书写成数字转义序列，首先需要查找字符的八进制或十六进制值。例如，某个ASCII码转义字符（十进制值为27）对应的八进制值为33，对应的十六进制值为1B。上述八进制或十六进制码可以用来书写转义序列。

- 八进制转义序列由字符`\`和跟随其后的一个最多含有三位数字的八进制数组成。（此数必须表示为无符号字符，所以最大值通常是八进制的377。）例如，可以将转义字符写成`\33`或`\033`。跟八进制常量不同，转义序列中的八进制数不一定要用0开头。
- 十六进制转义序列由`\x`和跟随其后的一个十六进制数组成。虽然标准C对于十六进制数的位数没有限制，但其必须表示成无符号字符（因此，如果字符长度是8位，那么十六进制数的值不能超过`FF`）。若采用这种表示法，可以把转义序列写成`\xlb`或`\xlB`的形式。字符`x`必须小写，但是十六进制的数字（例如`b`）不限大小写。

作为字符常量使用时，转义序列必须用一对单引号括起来。例如，表示转义字符的常量可以写成`\33`（或`\xlb`）的形式。转义序列可能有有点隐晦，所以采用`#define`的方式给它们命名通常是个不错的主意：

```c
#define ESC '\33'		/* ASCII escape character */
```

### 7.3.5 字符处理函数

调用C语言的`toupper`库函数可以把小写字母转换成大写字母：

```c
ch = toupper(ch);		/* converts ch to upper case */
```

`toupper`函数在被调用时检测参数是否是小写字母。如果是，它会把参数转换成相应的大写字母；否则，`toupper`函数会返回参数u的值。

调用`toupper` 函数的程序需要在顶部放置下面这条`#include`指令：

```c
#include <ctype.h>
```

### 7.3.6	用`scanf`和`printf`读/写字符

转换说明`%c`允许`scanf`函数和`printf`函数对单个字符进行读/写操作：

```c
char ch;

scanf("%c", &ch);		/* reads a single character */
printf("%c", ch);		/* writes a single character */
```

在读入字符前，`scanf`函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面的例子中，`scanf`函数返回后变量`ch`将包含一个空格。为了强制`scanf`函数在读入字符前跳过空白字符，需要在格式串中的转换说明`%c`前面加上一个空格：

```c
scanf(" %c", &ch);	/* skips white space, then reads ch */
```

通常情况下`scanf`函数不会跳过空白，所以它很容易检查到输入行的结尾：检查刚读入的字符是否为换行符。例如，下面的循环将读入并且忽略掉当前输入行中剩下的所有字符：

```c
do {
  scanf("%c", &ch);
} while (ch != '\n');
```

下次调用`scanf`函数时，将读入下一输入行中的第一个字符。

### 7.3.7 用`getchar`和`putchar`读/写字符

​	`putchar`函数用于写单个字符：

```c
putchar(ch);
```

每次调用`gerchar`函数时，它会读入一个字符并将其返回。为了保存这个字符，必须使用赋值操作将其存储到变量中：

```c
ch = getchar();		/* reads a character and stores it in ch */
```

事实上，`getchar`函数返回的是一个`int`类型的值而不是`char`类型的值。

和`scanf`函数一样，`getchar`函数也不会在读取时跳过空白字符。

## 7.4 类型转换

编译器可以自动处理值类型的转换无需程序员的介入，所以这类转换称为***隐式转换***（implicit conversion）。C语言还允许程序员使用强制运算符执行***显示转换***（explicit conversion）。

当发生下列情况时会进行隐式转换。

- 当算术表达式或逻辑表达式中操作数的类型不相同时。（C语言执行所谓的常用算术转换。）
- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。
- 当函数调用中的实参类型与其对应的形参类型不匹配时。
- 当`return`语句中表达式的类型和函数返回值的类型不匹配时。

### 7.4.1 常用算术转换

常用算术转换可用于大多数二元运算符（包括算术运算符、关系运算符和判等运算符）的操作数。整数始终可以转换成为`float`类型；可能会发生的最糟糕的事是精度会有少量损失。相反，把浮点数转换成为`int`类型，将有小数部分的损失；更糟糕的是，如果原始数大于最大可能的整数或者小于最小的整数，那么将会得到一个完全没有意义的结果。

常用算术转换的策略是把操作数转换成可以安全地适用于两个数值的“最狭小的”数据类型。（粗略地说，如果某种类型要求的存储字节比另一种类型少，那么这种类型就比另一种类型更狭小。）为了统一操作数的类型，通常可以将相对较狭小类型的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的提升是***整值提升***（integral promotion），它把字符或短整数转换成`int`类型（或者某些情况下是`unsigned int`类型）。

执行常用算术转换的规则可以划分成两种情况。

- **任一操作数的类型是浮点类型的情况。**按照下图将类型较狭小的操作数进行提升：

  `long double`

  ​		↑

     `double`

  ​		↑

     `float`	

  也就是说，如果一个操作数的类型为`long double`，那么把另一个操作数的类型转换成`long double`类型。

  否则，如果一个操作数的类型为`double`，那么把另一个操作数的类型转换成`double`类型。

  否则，如果一个操作数的类型为`float`，那么把另一个操作数的类型转换成`float`类型。

  这些规则涵盖了混合整数和浮点类型的情况。例如，如果一个操作数的类型是`long int`类型，并且另一个操作数的类型是`double`类型，那么把`long int`类型的操作数转换成`double`类型。

- **两个操作数的类型都不是浮点类型的情况。**首先对两个操作数进行整值提升（保证没有一个操作数是字符类型或短整型）。然后按照下图对类型较狭小的操作数进行提升：

  `unsigned long int`

  ​				 ↑

  ​	     `long int`

  ​		   	  ↑

  ​	   `unsigned int`

  ​				 ↑

  ​			  `int`

  有一种特殊情况，只有在`long int`类型和`unsigned int`类型长度（比如32位）相同时才会发生。在这类情况下，如果一个操作数的类型是`long int`，而另一个的类型是`unsigned int`，那么这两个操作数都会转换成`unsigned long int`类型。

### 7.4.2 赋值过程中的转换

常用算术转换不适用于赋值运算。C语言会遵循另一条简单的转换规则，那就是把赋值运算右边的表达式转换成左边变量的类型。如果变量的类型至少和表达式类型一样“宽”，那么这种转换将没有任何障碍。例如：

```c
char c;
int i;
float f;
double d;

i = c;		/* c is converted to int	  */
f = i;		/* i is converted to float  */
d = f;		/* f is converted to double */
```

其他情况下是有问题的。把浮点数赋值给整型变量会丢掉该数的小数部分：

```c
int i;

i = 842.97;		/* i is now 842  */
i = -842.97;	/* i is now -842 */
```

此外，把某种类型的值赋给类型更狭小的变量时，如果该值在变量类型范围之外，那么将会得到无意义的结果（甚至更糟）。

```c
c = 10000;		/*** WRONG ***/
i = 1.0e20; 	/*** WRONG ***/
f = 1.0e100;	/*** WRONG ***/
```

### 7.4.3 C99中的隐式转换（C99）

为了定义转换规则，C99允许每个整数类型具有“整数转换等级”。下面按从最高级到最低级的顺序排列。

（1）`long long int`、`unsigned long long int`

（2）`long int`、`unsigned long int`

（3）`int`、`unsigned int`

（4）`short int`、unsigned short int

（5）`char`、`signed char`、`unsigned char`

（6）`_Bool`

C99用整数提升（integer promotion）取代了C89中的整值提升（integral promotion），可以将任何等级低于`int`和`unsigned int`和类型转换为`int`（只要该类型的所有值都可以用`int`类型表示）或`unsigned int`。

与C89一样，C99中执行常用算术转换的规则可以划分为两种情况。

- **任一操作数的类型是浮点类型的情况。**只要两种操作数都不是复数型，规则与前面一样。
- **两个操作数的类型都不是浮点类型的情况。**首先对两个操作数进行整数提升。如果这时两个操作数的类型相同，过程结束。否则，依次尝试下面的规则，一旦遇到可应用的规则就不再考虑别的规则：
  - 如果两个操作数都是有符号型或者都是无符号型，将整数转换等级较低的操作数转换为等级较高的操作数的类型；
  - 如果无符号操作数的等级高于或等于有符号操作数的等级，将有符号操作数转换为无符号操作数的类型。
  - 如果有符号操作数类型可以表示无符号操作数类型的所有值，将无符号操作数转换为有符号操作数的类型。
  - 否则，将两个操作数都转换为与有符号操作数的类型相对应的无符号类型。

另外，所有算术类型都可以转换为`_Bool`类型。如果原始值为0则转换结果为0，否则结果为1.

### 7.4.4 强制类型转换

当我们需要从更大程度上控制类型转换时，C语言提供了***强制类型转换***（casts）。强制类型转换表达式的格式如下：

```c
( type-name ) expression
```

这里的type-name表示的是表达式应该转换成的类型。



下面的例子显示了使用强制类型转换表达式计算`float`类型值小数部分的方法：

```c
float f, frac_part;
frac_part = f - (int) f;
```

　强制类型转换表达式可以用于显示那些肯定会发生的类型转换：

```c
i = (int) f;		/* f is converted to int */
```



它也可以用来控制编译器并且强制它进行我们需要的转换：

```c
float quotient;
int dividend, divisor;

quotient = (float) dividend / divisor;
```

为了得到更精确的结果，需要在除法执行之前把`dividend`和`divisor`的类型转换成`float`格式。



C语言把`( type-name )`视为一元运算符。一元运算符的优先级高于二元运算符，所以编译器会把表达式

```c
(float) dividend / divisor
```

解释为

```c
((float) dividend) / divisor
```



有些时候，需要使用强制类型转换来避免溢出。

```c
long i;
int j = 1000;

i = j * j;		/* overflow may occur */
```

当两个`int`类型值相乘时，结果也应该是`int`类型的，但是`j * j`的结果太大，以致在某些机器上无法表示成``int`型，从而导致溢出。因此，可以使用强制类型转换避免这种事情发生：

```c
i = (long) j * j;
```

因为强制运算符的优先级高于`*`，所以第一个变量`j`会转换成`long int`类型，同时也迫使第二个`j`进行转换。

## 7.5 类型定义（type definition）

使用类型定义设置布尔类型：

```c
typedef int Bool;
```

采用`typedef`定义`Bool`会导致编译器在它所识别的类型名列表中加入`Bool`。现在，`Bool`类型可以和内置的类型名一样用于变量声明、强制类型转换表达式和其他地方了。

### 7.5.1 类型定义的优点

类型定义使程序更加易于理解（假定选择了有意义的类型名）。

类型定义还可以使程序更容易修改。

### 7.5.2 类型定义和可移植性

程序从一台计算机移动到另一台计算机可能引发的问题之一就是不同计算机上的类型取值范围可能不同。

为了更大的可移植性，可以考虑使用`typedef`定义新的整数类型名。

(C99)在C99中，`<stdint.h>`头使用`typedef`定义占用特定位数的整数类型名。例如，`int32_t`是恰好占用32位的有符整型。这是一种有效的定义方式，能使程序更易于移植。

## 7.6 `sizeof`运算符

`sizeof`运算符允许程序存储指定类型值所需空间的大小。表达式

```c
sizeof ( type-name )
```

是一个无符号整数，代表存储属于`type-name`的值所需要的字节数。

显示`sizeof`值时要注意，因为`sizeof`表达式的类型是`size_t`，这是一种由实现定义的类型。在C89中，最好在显示前把表达式的值转换成一种已知的类型。`size_t`一定是无符号整型，所以最安全的方法是把`sizeof`表达式强制转换成`unsigned long`类型（C89中最大的无符号类型），然后使用转换说明符`%lu`显示：

```c
printf("Size of int: %lu\n", (unsigned long) sizeof(int));
```

（C99）在C99中，`size_t`类型可以比`unsigned long`更长。但C99中的`printf`可以直接显示出`size_t`类型值而不需要强制转换。方法是在转换说明中的一般整数（通常是`u`）代码前使用字母`z`：

```c
printf("Size of int: %zu\n", sizeof(int));		/* C99 only */
```

