# Ch8 数组

到目前为止，所见到的变量都只是标量（scalar）：标量具有保存单一数据项的能力。

C语言支持聚合（aggregate）变量，这类变量可以存储一组一组的数值。

C语言中有两种聚合类型：数组（array）和结构（structure）。



本章内容

数组和多维数组的声明和使用

C99中的变长数组

## 8.1 一维数组

数组是含有多个数据值的数据结构，并且每个数据值具有相同的数据类型。这些数据值称为元素（element），可以根据元素在数组中所处的位置把他们一个个的选出来。

最简单的数组类型就是一维数组，一维数组中的元素一个接一个地编排在单独一行内。

为了声明数组，需要指明数组元素的类型和数量。例如声明数组`a`有10个`int`类型的元素:

```c
int a[10];
```

数组的元素可以是任何类型，数组的长度可以用任何（整数）常量表达式指定。因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

```C
#define N 10

...

int a[N];
```



### 8.1.1 数组下标

为了存取特定的数组元素，可以在写数组名的同时在后边加上一个用方括号围绕的整数值（称这是对数组取下标（subscripting）或进行索引（indexing））。数组元素始终从0开始，所以长度为n的数组元素的索引是从0到n-1。

形如`a[i]`的表达式是左值，所以数组元素可以像普通变量一样使用：

```c
a[0] = 1;
printf("%d\n", a[5]);
++a[i];
```

数组和`for`循环结合在一起使用。许多程序所包含的`for`循环都是为了对数组中的每个元素执行一些操作。下面给出了在长度为`N`的数组上的一些常见操作示例。

```c
for (i = 0; i < N; i++)
  a[i] = 0;							/* clear a */
for (i = 0; i < N; i++)
  scanf("%d", &a[i]);		/* reads data into a */
for (i = 0; i < N; i++)
  sum += a[i];					/* sums the elements of a */
```



### 8.1.2 数组初始化

数组初始化式（array initializer）最常见的格式：

```c
int a[5] = {1, 2, 3, 4, 5};
```

如果初始化式比数组短，那么数组中剩余的元素赋值为0：

```c
int a[10] = {1, 2, 3, 4, 5};
```

初始化式完全为空是非法的，所以要在大括号内放上一个0。初始化式比要初始化的数组长也是非法的。

如果给定了初始化式，可以省略掉数组的长度：

```c
int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```


编译器通过初始化式的长度来确定数组的大小。数组仍然有固定数量的元素，这跟明确地指定长度效果一样。

### 8.1.3 指定初始化式（C99）

数组中只有相对较少的元素需要进行显式的初始化，而其他元素可以进行默认赋值。例如：

```c
int a[15] = {0, 0, 29, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 48};
```

对于大数组，如果使用这种方式赋值，将是冗余和容易出错的。C99中的指定初始化式可以用于解决这一问题：

```c
int a[15] = {[2] = 29, [9] = 7, [14] = 48};
```


括号中的数字称为指示符。

除了可以使赋值变得更简短、更易读之外，而且赋值的顺序不再是一个问题：

```C
int a[15] = {[14] = 48, [9] = 7, [2] = 29};
```

指示符必须是整型常量表达式。如果待初始化的数组长度为n，则每个指示符的值必须在0和n-1之间。但是，如果数组的长度是省略的，指示符可以是任意非负整数；对于后一种情况，编译器将根据最大的指示符推断出数组的长度。

```c
int b[] = {[5] = 10, [23] = 13, [11] = 36, [15] = 29}; //数组的长度为24 
```

### 8.1.4 对数组使用sizeof运算符

运算符sizeof可以确定数组的大小（字节数）。如果数组a有10个整数，那么`sizeof(a)`通常为40（假定每个整数占4个字节）。

还可以用sizeof来计算数组元素（如`a[0]`）的大小。
用数组的大小除以数组元素的大小可以得到数组的长度：
		`sizeof(a) / sizeof(a[0])`

当需要数组长度时，一些程序员采用上述这个表达式。例如，数组a的清零操作可以写成如下形式：

```c
for (i = 0; i < sizeof(a)/sizeof(a[0]); i++)
	a[i] = 0;
```

如果用这种方法，即使数组长度日后需要改变，也不需要改变循环。当然，利用宏来表示数组的长度也有同样的好处，但是sizeof方法稍微好一些，因为不需要记忆宏的名字（有可能报错）。

有些编译器会对表达式` i < sizeof(a)  / sizeof(a[0])`给出一条警告信息
变量i的类型可能是int（有符号类型），而sizeof返回的值的类型为`size_t`（一种无符号类型）。把有符号整数与无符号整数相比较是很危险的，为了避免警告，可以把`sizeof(a) / sizeof(a[0])`强制转换为有符号整数：

```c
for ( i = 0; i < (int) (sizeof(a)/sizeof(a[0]); i++)
	a[ i ] = 0;
```

表达式`(int) (sizeof(a) / sizeof(a[0])`写起来不方便，可以定义一个宏：

```c
#define SIZE ((int) (sizeof(a)/sizeof(a[0]))

for (i =0; i < SIZE; i++)
	a[i] = 0;
```

## 8.2 多维数组

数组可以有任意维度。例如，下面的声明可以产生一个二维数组：

```c
int m[5][9];
```

为了访问`i`行`j`列的元素，需要写成`m[i][j]`的形式。表达式`m[i]`指明了数组`m`的第`i`行，而`m[i][j]`则选择了此行中的第`j`个元素。

在计算机的内存中，C语言是按照行主序存储数组的，也就是从第0行开始，接着第一行，以此类推。

嵌套的`for`循环是处理多维数组的理想选择。在某些系统方式中，我们需要访问数组中的每一个元素。一对嵌套的`for`循环可以很好地完成这项工作——一个遍历每一行，另一个遍历每一列：

```c
#define N 10

double ident[N][N];
int row, col;

for (row = 0; row < N; row++)
  for (col = 0; col < N; col++)
    if (row == col)
      ident[row][col] = 1.0;
		else
      ident[row][col] = 0.0;
```



### 8.2.1 多维数组初始化

通过嵌套一维初始化式的方法可以产生二维数组的初始化式：

```C
int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1},
							 {0, 1, 0, 1, 0, 1, 0, 1, 0},
							 {0, 1, 0, 1, 1, 0, 0, 1, 0},
							 {1, 1, 0, 1, 0, 0, 0, 1, 0},
							 {1, 1, 0, 1, 0, 0, 1, 1, 1}};
```

C语言为多维数组提供了多种方法来缩写初始化式。
如果初始化式没有大到足以填满整个多维数组，那么把数组中剩余的元素赋值为0。例如，下面的初始化式只填充了数组`m`的前三行，后边的两行将赋值为0：

```c
int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1},
							 {0, 1, 0, 1, 0, 1, 0, 1, 0},
							 {0, 1, 0, 1, 1, 0, 0, 1, 0}};
```

如果内层的列表没有大到足以填满数组的一行，那么把此行剩余的元素初始化为0。

```C
int m[5][9] = {{1, 1, 1, 1, 1, 0, 1, 1, 1},
							 {0, 1, 0, 1, 0, 1, 0, 1},
							 {0, 1, 0, 1, 1, 0, 0, 1},
							 {1, 1, 0, 1, 0, 0, 0, 1},
               {1, 1, 0, 1, 0, 0, 1, 1, 1}};
```

甚至可以省略掉内层的花括号：

```c
int m[5][9] = {1, 1, 1, 1, 1, 0, 1, 1, 1,
							 0, 1, 0, 1, 0, 1, 0, 1, 0,
							 0, 1, 0, 1, 1, 0, 0, 1, 0,
							 1, 1, 0, 1, 0, 0, 0, 1, 0,
							 1, 1, 0, 1, 0, 0, 1, 1, 1};
```

因为一旦编译器发现数值足以填满一行，它就开始填充下一行。



(C99)C99的指定初始化式对多维数组也有效。

```c
double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0};
```


像通常一样，没有指定值的元素都默认置为0。

### 8.2.2 常量数组

无论是一位数组还是多维数组，都可以通过在声明的最开始处加上单词`const`而成为“常量”

```c
const char hex_chars[] = {‘0’, ‘1’, ‘2’, ... , ‘9’};
```

程序不应该对声明`const`的数组进行修改，编译器能够检测到直接修改某个元素的意图。

把数组声明为`const`有两个主要的好处。它表明程序不会改变数组，这对于以后阅读程序的人可能是有价值的信息。
它还有助于编译器发现错误——`const`会告诉编译器我们不打算修改数组。 

`const`类型限定符不限于数组，它可以和任何变量一起使用。但是，`const`在数组声明中特别有用，因为数组经常含有一些在程序执行过程中不会发生改变的参考信息。

## 8.3 C99中的变长数组（C99)

```c
/* reverse2.c */
/* Reverses a series of numbers using a variable0length array - C99 only */

#include <stdio.h>

int main(void)
{
  int i, n;
  
  printf("How many numbers do you want to reverse? ");
  scanf("%d", &n);
  
  int a[n]; /* C99 only - length of array depends on n */
  
  printf("Enter %d numbers: ", n);
  for (i = 0; i < n; i++)
    scanf("%d", &a[i]);
  printf("In reverse order:");
  for (i = n -1; i >= 0; i--)
    printf(" %d", a[i])
  printf("\n");
  
  return 0;
}
```

`a`是一个变长数组（variable-length array， 简称VLA）。变长数组的长度是在程序执行时计算的，而不是在程序编译时计算的。
变长数组的主要优点是程序员不必在构造数组时随便给定一个长度，程序在执行时可以准确地计算出所需的元素个数。

变长数组的长度不一定要用变量来指定，任意表达式（可以含有运算符）都可以。

```c
int a[3 * i + 5];
int b[j + k];
```

变长数组可以是多维的

```c
int c[m][n];
```

变长数组的主要限制是它们没有静态存储期限，另一个限制是变长数组没有初始化式。

变长数组常见于除`main`函数以外的其他函数。对于函数f而言，变长数组的最大优势就是每次调用`f`时长度可以不同。

